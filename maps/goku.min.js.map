{"version":3,"sources":["goku.js","transition.js"],"names":["exports","isObjectEmpty","obj","key","hasOwnProperty","newId","gokuIndex","goku","element","Error","document","querySelector","elements","dataset","gokuId","id","Transition","onstart","requestId","console","log","requestAnimationFrame","step","oncomplete","cancelAnimationFrame","timestamp","window","webkitRequestAnimationFrame","mozRequestAnimationFrame","callback","setTimeout","webkitCancelAnimationFrame","mozCancelAnimationFrame","clearTimeout","options","this","_clear","bind","queue","timings","playingIndex","elapsedTime","lastTimestamp","isPaused","pausingIndex","promiseQueue","animate","delay","pause","DEFAULT_DURATION","DEFAULT_EASING","prototype","_generatePromiseTask","promiseTask","promise","Promise","resolve","reject","_generateTransform","value","originalTransform","getComputedStyle","transform","style","_generateTransformByMatrix","addClass","args","Array","slice","call","arguments","properties","transitionPropertyArray","push","transitionProperty","join","duration","that","task","start","transitionDuration","transitionTimingFunction","easing","offsetWidth","length","time","play","reset","reverse","next","finish","index","forEach","_next","styles","complete","before"],"mappings":"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","file":"goku.min.js","sourcesContent":["/* global Transition */\n(function (exports) {\n  'use strict';\n\n  var requestId;\n\n  var elements = {};\n\n  var gokuIndex = 0;\n\n  var requestAnimationFrame = window.requestAnimationFrame ||\n                              window.webkitRequestAnimationFrame ||\n                              window.mozRequestAnimationFrame ||\n                              function fakeAnimationFrame(callback) {\n                                return window.setTimeout(callback, 1000 / 60);\n                              };\n\n  var cancelAnimationFrame = window.cancelAnimationFrame ||\n                             window.webkitCancelAnimationFrame ||\n                             window.mozCancelAnimationFrame ||\n                             function fakeAnimationFrame(id) {\n                               window.clearTimeout(id);\n                             };\n\n  function isObjectEmpty(obj) {\n    if (!obj) {\n      return true;\n    }\n\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function newId () {\n    return 'goku-' + gokuIndex++;\n  }\n\n  function goku (element) {\n    if (!element) {\n      throw new Error('Goku: no argument');\n    }\n\n    if (typeof element === 'string') {\n      element = document.querySelector(element);\n    }\n\n    if (!element) {\n      throw new Error('Goku: no element found');\n    }\n\n    if (elements[element.dataset.gokuId]) {\n      return elements[element.dataset.gokuId];\n    }\n\n    // Use MutationObserver to release the obj when done\n    // https://developer.mozilla.org/en/docs/Web/API/MutationObserver\n    // https://hacks.mozilla.org/2012/05/dom-mutationobserver-reacting-to-dom-changes-without-killing-browser-performance/\n    // http://jsbin.com/yeferi/1/edit?html,js,console,output\n\n    // var that = this;\n    var id = newId();\n\n    element.dataset.gokuId = id;\n\n    elements[id] = new Transition(element, {\n      id: id,\n      onstart: function () {\n        if (!requestId) {\n          console.log('goku.js: start animation loop');\n          requestId = requestAnimationFrame(step);\n        }\n      },\n      oncomplete: function (element) {\n        var id = element.dataset.gokuId;\n        delete element.dataset.gokuId;\n        delete elements[id];\n        if (isObjectEmpty(elements)) {\n          console.log('goku.js: complete animation loop');\n          cancelAnimationFrame(requestId);\n          requestId = null;\n        }\n      }\n    });\n\n    return elements[id];\n  }\n\n  /**\n   * The main and only loop for monitoring animated elements.\n   * @param  {[type]} timestamp [description]\n   * @return {[type]}           [description]\n   */\n  function step (timestamp) {\n    requestId = requestAnimationFrame(step);\n    // console.log(timestamp);\n    for (var key in elements) {\n      if (elements[key].step) {\n        elements[key].step(timestamp);\n      }\n    }\n  }\n\n  exports.goku = goku;\n\n})(window);\n","(function (exports) {\n  'use strict';\n\n  // var TRANSITION_FINISH_THRESHOLD = 0;\n  var DEFAULT_DURATION = 400;\n  var DEFAULT_EASING = 'ease';\n\n  function Transition (element, options) {\n    // Currently only support ES6 Promise, add support for various promise implementations later.\n    options = options || {};\n    this.element = element;\n    this.id = options.id;\n    this.onstart = options.onstart;\n    this.oncomplete = function () {\n      this._clear();\n      options.oncomplete(this.element);\n    }.bind(this);\n\n    // this.element.style.transitionProperty = 'transform';\n    // log purpose only\n    // this.element.addEventListener('transitionend', function (evt) {\n    //   console.log('transitionend', evt);\n    // });\n\n    this.queue = [];\n    this.timings = [];\n    this.playingIndex = -1;\n    this.elapsedTime = 0;\n    this.lastTimestamp = 0;\n    this.isPaused = false;\n    this.pausingIndex = -1;\n    this.promiseQueue = [];\n\n    this.animate = this.animate.bind(this);\n    this.delay = this.delay.bind(this);\n    this.pause = this.pause.bind(this);\n  }\n\n  Transition.prototype = {\n\n    _generatePromiseTask: function () {\n      var promiseTask = {};\n      var promise = new Promise(function (resolve, reject) {\n        promiseTask.resolve = resolve;\n        promiseTask.reject = reject;\n      });\n      promise.animate = this.animate;\n      promise.delay = this.delay;\n      promise.pause = this.pause;\n      promiseTask.promise = promise;\n\n      return promiseTask;\n    },\n\n    /**\n     * Update the transform value of an element by chaining the original and the new transform values.\n     * @param  {[type]} element [description]\n     * @param  {[type]} value   [description]\n     * @return {[type]}         [description]\n     */\n    _generateTransform: function (element, value) {\n      var originalTransform = getComputedStyle(element).transform;\n      if (originalTransform === 'none') {\n        element.style.transform = value;\n      } else {\n        element.style.transform = originalTransform + ' ' + value;\n      }\n    },\n\n    /**\n     * Maybe try this approach later for performance comparisons.\n     * @param  {[type]} element [description]\n     * @param  {[type]} value   [description]\n     * @return {[type]}         [description]\n     */\n    _generateTransformByMatrix: function (/*element, value*/) {\n      // If transform was applied on the element\n        // Get originial transform matrix\n        // Get new transform matrix\n        // Compute the result transform matrix\n      // Else, set the value directly\n\n    },\n\n    addClass: function (/*className*/) {},\n\n    /**\n     * By default the animate calls are queued.\n     * @return {[type]} [description]\n     */\n    animate: function () {\n      // Optimize this later\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\n      var args = Array.prototype.slice.call(arguments);\n\n      if (!args[0]) {\n        throw new Error('Goku: missing arguments!');\n      }\n\n      if (typeof args[0] === 'string') {\n        // Run animation by adding CSS class\n        throw new Error('Goku: implement this!');\n      }\n\n      if (typeof args[0] === 'object') {\n        var properties = args[0];\n        var options = args[1] || {};\n\n        var transitionPropertyArray = [];\n        for (var key in properties) {\n          transitionPropertyArray.push(key);\n        }\n        var transitionProperty = transitionPropertyArray.join(' ');\n        var duration = options.duration || DEFAULT_DURATION;\n        this.timings.push(duration);\n\n        var that = this;\n        var task = {\n          properties: properties,\n          options: options,\n          start: function () {\n            that.element.style.transitionProperty = transitionProperty;\n            that.element.style.transitionDuration = duration + 'ms';\n            that.element.style.transitionTimingFunction = options.easing || DEFAULT_EASING;\n            // Workaround for triggering a transition.\n            // http://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element\n            /* jshint -W030 */\n            that.element.offsetWidth;\n            for (var key in properties) {\n              if (key === 'transform') {\n                // Although this is helpful, but it contradicts the principle of CSS rules.\n                // that._generateTransform(that.element, properties[key]);\n                that.element.style[key] = properties[key];\n              } else {\n                that.element.style[key] = properties[key];\n              }\n            }\n\n            if (options.start) {\n              options.start();\n            }\n          }\n        };\n\n        this.queue.push(task);\n        if (this.queue.length === 1) {\n          this.onstart();\n        }\n\n        var promiseTask = this._generatePromiseTask();\n        this.promiseQueue.push(promiseTask);\n        return promiseTask.promise;\n      }\n    },\n\n    delay: function (time) {\n      console.log(this.id, 'delay');\n      if (time > 0) {\n        this.queue.push({});\n        this.timings.push(time);\n      } else {\n        throw new Error('Goku: missing arguments!');\n      }\n\n      if (this.queue.length === 1) {\n        this.onstart();\n      }\n\n      var promiseTask = this._generatePromiseTask();\n      this.promiseQueue.push(promiseTask);\n      return promiseTask.promise;\n    },\n\n    pause: function () {\n      console.log(this.id, 'pause');\n      this.isPaused = true;\n\n      return this;\n    },\n\n    play: function () {\n      console.log(this.id, 'play');\n      this.isPaused = false;\n\n      return this.promiseQueue[this.playingIndex].promise;\n    },\n\n    reset: function () {},\n\n    reverse: function () {},\n\n    next: function () {},\n\n    /**\n     * End the animation immediately.\n     * @return {[type]} [description]\n     */\n    finish: function () {\n      console.log(this.id, 'finish');\n      // Get the last animation task and its properties in the queue\n      var index = this.queue.length - 1;\n      var properties = this.queue[index].properties;\n      while (!properties) {\n        properties = this.queue[index].properties;\n        index -= 1;\n      }\n      // Remove transition-properties tyle\n      this.element.style.transitionProperty = 'none';\n      // Apply the final style properties onto the element\n      for (var key in properties) {\n        this.element.style[key] = properties[key];\n      }\n      // Workaround for triggering a reflow and repaint.\n      // http://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element\n      /* jshint -W030 */\n      this.element.offsetWidth;\n      // Resolving promises following the logic as follows to prevent error\n      // when animate is called in the then() callback.\n      // Save promiseQueue reference to be resolved below.\n      var promiseQueue = this.promiseQueue;\n      // Clean up transition tasks including the promiseQueue.\n      this.oncomplete();\n      // Resolve promises\n      promiseQueue.forEach(function (promise) {\n        promise.resolve();\n      });\n\n      return this;\n    },\n\n    step: function (timestamp) {\n      // timestamp is started when page loaded, reset the elapsed time first\n      if (!this.isPaused && this.lastTimestamp) {\n        this.elapsedTime += timestamp - this.lastTimestamp;\n      }\n      this.lastTimestamp = timestamp;\n\n      if (this.playingIndex === -1) {\n        this._next();\n        return;\n      }\n\n      if (this.isPaused && this.pausingIndex > -1) {\n        return;\n      }\n\n      var task;\n      var properties;\n      var key;\n\n      if (this.isPaused && this.pausingIndex < 0) {\n        // Set the current style to element.style\n        this.pausingIndex = this.playingIndex;\n        var styles = getComputedStyle(this.element);\n        task = this.queue[this.playingIndex];\n        properties = task.properties;\n\n        for (key in properties) {\n          this.element.style[key] = styles[key];\n        }\n\n        return;\n      }\n\n      if (!this.isPaused && this.pausingIndex > -1) {\n        this.pausingIndex = -1;\n        task = this.queue[this.playingIndex];\n        properties = task.properties;\n\n        for (key in properties) {\n          this.element.style[key] = properties[key];\n        }\n\n        return;\n      }\n\n      // if (!this.isPaused) {\n      //   console.log('step', this.id, this.elapsedTime);\n      // }\n\n      if (this.elapsedTime > this.timings[this.playingIndex]) {\n        task = this.queue[this.playingIndex];\n        if (task.options && typeof task.options.complete === 'function') {\n          task.options.complete();\n        }\n        var promiseTask = this.promiseQueue[this.playingIndex];\n        promiseTask.resolve();\n        this._next();\n      }\n    },\n\n    _next: function () {\n      this.playingIndex += 1;\n\n      if (this.queue[this.playingIndex]) {\n        console.log(this.id, 'next');\n\n        var task = this.queue[this.playingIndex];\n        if (task.options && typeof task.options.before === 'function') {\n          task.options.before();\n        }\n\n        if (task.start && typeof task.start === 'function') {\n          task.start();\n        }\n\n        this.elapsedTime = 0;\n        this.lastTimestamp = 0;\n\n      } else {\n        console.log(this.id, 'end');\n        this.oncomplete();\n      }\n    },\n\n    _clear: function () {\n      console.log(this.id, 'clear');\n      this.playingIndex = -1;\n      this.queue.length = 0;\n      this.timings.length = 0;\n      this.elapsedTime = 0;\n      this.lastTimestamp = 0;\n      this.isPaused = false;\n      this.pausingIndex = -1;\n      this.promiseQueue = [];\n    }\n  };\n\n  exports.Transition = Transition;\n\n})(window);\n"],"sourceRoot":"/source/"}